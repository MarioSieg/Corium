CompilationUnit = {
    SOI ~ Module? ~ (GlobalStatement | StatementSeparator)* ~ EOI
}

GlobalStatement = {
    Function |
    NativeFunction |
    MutableVariable |
    ImmutableVariable
}

Function = {
     FunctionSignature ~ " {" ~ NEWLINE ~ Block ~ "}" ~ NEWLINE
}

NativeFunction = {
    "native " ~ FunctionSignature ~ NEWLINE
}

FunctionSignature = {
    "function " ~ Identifier ~ " (" ~ ParameterList? ~ ")" ~ (" " ~ QualifiedName)?
}

Block = {
     (LocalStatement | StatementSeparator)*
}

LocalStatement = {
    MutableVariable |
    ImmutableVariable |
    ReturnStatement
}

Module = {
    "module " ~ QualifiedName ~ NEWLINE
}

MutableVariable = {
    "let " ~ Identifier ~ (" " ~ QualifiedName)? ~ " = " ~ Expression ~ NEWLINE
}

ImmutableVariable = {
    "const " ~ Identifier ~ (" " ~ QualifiedName)? ~ " = " ~ Expression ~ NEWLINE
}

ReturnStatement = {
    "return" ~ (" " ~ Expression)? ~ NEWLINE
}

ParameterList = {
    (Parameter ~ (", " ~ Parameter)*)
}

Parameter = {
    Identifier ~ " " ~ QualifiedName ~ (" = " ~ Expression)?
}

Expression = {
    RootExpression ~ (Whitespace? ~ BinaryOperator ~ Whitespace? ~ RootExpression)*
}

RootExpression = {
    LiteralExpression |
    IdentifierExpression |
    ParenthesisExpression |
    UnaryExpression
}

LiteralExpression = {
    Literal
}

IdentifierExpression = {
    Identifier
}

ParenthesisExpression = {
    "(" ~ Expression ~ ")"
}

UnaryExpression = {
    UnaryOperator ~ RootExpression
}

BinaryOperator = {
   // Arithmetic
   "+" |   // addition
   "-" |   // subtraction
   "*" |   // multiplication
   "/" |   // division
   "%" |   // modulo

   // Bitwise
   "&" |   // and
   "|" |   // or
   "^" |   // xor
  "<<<" | // rotate left
  ">>>" | // rotate right
   "<<" |  // shift left
   ">>" |  // shift right

   // Logical
   "and" | // and
   "or"    // or
}

UnaryOperator = {
    "+" |   // plus
    "-" |   // minus
    "~" |   // bitwise complement
    "not"   // logical not
}

Literal = {
    FloatLiteral |
    IntLiteral |
    BoolLiteral |
    CharLiteral |
    StringLiteral
}

QualifiedName = {
    Identifier ~ ("." ~ Identifier)*
}

FloatLiteral = @{
    (("_"? ~ ASCII_DIGIT)+ ~ "." ~ ("_"? ~ ASCII_DIGIT)+)
}

IntLiteral = @{
    (("_"? ~ ASCII_DIGIT)+)
}

BoolLiteral = @{
    "true" | "false"
}

CharLiteral = @{
    "'" ~ Char ~ "'"
}

StringLiteral = @{
    "\"" ~ Char* ~ "\""
}

Identifier = {
    ASCII_ALPHA ~ ASCII_ALPHANUMERIC*
}

Char = @{
    !("\"" | "\\") ~ ANY
    | "\\" ~ ("\"" | "\\" | "n" | "r" | "t")
    | "\\" ~ ("u" ~ ASCII_HEX_DIGIT{8})
}

StatementSeparator = _{
    NEWLINE |
    SEPARATOR
}

Whitespace = _{
   " " | "\t"
}

COMMENT = _{
    "#" ~ (!"\n" ~ ANY)*
}
